@page "/retro/{TeamId:guid}"
@page "/ru/retro/{TeamId:guid}"
@page "/en/retro/{TeamId:guid}"

@attribute [Authorize]

@implements IAsyncDisposable

@inject TenantStore TenantStore
@inject IRetroService RetroService
@inject RequestProcessor RequestProcessor
@inject IServiceProvider ServiceProvider

<MetaDataModule />

<AuthorizeView>
    <Authorized>
        @if (Team is not null)
        {
            var currentUser = context.User.ToPerson();
            
            <RetroGrid
                Team="@Team"
                State="_state"
                Columns="Columns"
                CurrentUserId="currentUser.Id"
                CanCreate="_canCreate"
                Retry="Load"
                ItemCreated="@(i => CreateRetroItem(i, currentUser.Id))"
                ItemChanged="ChangeRetroItem"
                ItemRemoved="RemoveRetroItem" />
        }
    </Authorized>
</AuthorizeView>

@code {
    [Parameter]
    public Guid TeamId { get; set; }
    
    [CascadingParameter]
    public Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;

    private TenantTeamDto? Team => TenantStore.Teams.SingleOrDefault(t => t.Id == TeamId);
    private IEnumerable<RetroColumnViewModel> Columns => _columns.Values;

    private bool _canCreate = true;
    private readonly LoadingState _state = LoadingState.Done();
    private RetroEventBuilder? _eventBuilder;
    private IAsyncDisposable? _eventListener;
    private readonly IReadOnlyDictionary<string, RetroColumnViewModel> _columns = new Dictionary<string, RetroColumnViewModel>
    {
        ["Start"] = new("Start", 1, "Start", ItemColor: "#FF8C00", new()),
        ["Stop"] = new("Stop", 2, "Stop", ItemColor: "#B22222", new()),
        ["Continue"] = new("Continue", 3, "Continue", ItemColor: "#3CB371", new())
    };
    
    protected override async Task OnParametersSetAsync()
    {
        await Load();

        await Reconnect();
    }
    
    private async Task Reconnect()
    {
        if (_eventListener is not null)
            await _eventListener.DisposeAsync();
        
        var eventBuilder = ServiceProvider.GetService<RetroEventBuilder>();
        if (eventBuilder is not null)
            _eventBuilder ??= await eventBuilder.Start();
        
        _eventListener = await StartListenEvents();
    }
    
    private async Task<IAsyncDisposable?> StartListenEvents()
    {
        if (_eventBuilder is null)
            return null;

        var authenticationState = await AuthenticationStateTask;
        var currentUser = authenticationState.User.ToPerson();

        return await _eventBuilder.Build(
            TeamId,
            b => b.OnRetroItemChanged(async i =>
            {
                if (currentUser.Id != i.OwnerId)
                    await InvokeAsync(() =>
                    {
                        ApplyChangedEvent(i);
                        StateHasChanged();
                    });
            }),
            b => b.OnRetroItemRemoved(async i =>
            {
                if (currentUser.Id != i.OwnerId)
                    await InvokeAsync(() =>
                    {
                        ApplyRemovedEvent(i.Type, i.Id);
                        StateHasChanged();
                    });
            }));
    }

    private async Task Load()
    {
        await TenantStore.Initialize(TeamId, _state);
        
        var result = await RequestProcessor.Process(
            async () => await RetroService.GetItems(TeamId),
            nameof(RetroGridContainer),
            _state);
        
        foreach (var item in result.Items)
            ApplyChangedEvent(item);
    }

    private async Task CreateRetroItem(string type, long ownerId)
    {
        if (!_columns.TryGetValue(type, out var column))
            return;
        
        _canCreate = false;

        try
        {
            var command = new CreateRetroItemCommand(TeamId, type, Text: null);
            var result = await RequestProcessor.Process(
                async () => await RetroService.CreateRetroItem(command),
                _state,
                showLoading: false);

            column.Items.Add(RetroItemViewModel.Create(result.Id, ownerId, type));
        }
        finally
        {
            _canCreate = true;
        }
    }

    private async Task ChangeRetroItem(RetroItemViewModel item)
    {
        await RequestProcessor.Process(
            async () => await RetroService.UpdateRetroItem(item.ToCommand()),
            _state,
            showLoading: false);
    }

    private void ApplyChangedEvent(RetroItemDto item)
    {
        if (!_columns.TryGetValue(item.Type, out var column))
            return;
        
        var viewItem = column.Items.SingleOrDefault(i => i.Id == item.Id);
        if (viewItem is null)
            column.Items.Add(RetroItemViewModel.Create(item.Id, item.OwnerId, item.Type).Apply(item));
        else
            viewItem.Apply(item);
    }
    
    private async Task RemoveRetroItem(RetroItemViewModel item)
    {
        await RequestProcessor.Process(
            async () => await RetroService.RemoveRetroItem(item.Id),
            _state,
            showLoading: false);

        ApplyRemovedEvent(item.Type, item.Id);
    }

    private void ApplyRemovedEvent(string type, Guid itemId)
    {
        if (!_columns.TryGetValue(type, out var column))
            return;
        
        var viewItem = column.Items.SingleOrDefault(i => i.Id == itemId);
        if (viewItem is not null)
            column.Items.Remove(viewItem);
    }
    
    public async ValueTask DisposeAsync()
    {
        if (_eventListener is not null)
        {
            await _eventListener.DisposeAsync();
            _eventListener = null;
        }
        
        if (_eventBuilder is not null)
        {
            await _eventBuilder.DisposeAsync();
            _eventBuilder = null;
        }
    }
}