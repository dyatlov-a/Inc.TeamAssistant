@inject IJSRuntime JsRuntime
@inject IRenderContext RenderContext

<div
    style="background-color: @BackgroundColor"
    class="retro-item"
    contenteditable="true"
    @oninput="HandleInput"
    @ref="_item">
    @if (!RenderContext.IsBrowser)
    {
        @Value.Text
    }
</div>

@code {
    /// <summary>
    /// Retro item.
    /// </summary>
    [Parameter, EditorRequired]
    public RetroItemViewModel Value { get; set; } = default!;
    
    /// <summary>
    /// Value changed callback.
    /// </summary>
    [Parameter, EditorRequired]
    public EventCallback<RetroItemViewModel> ValueChanged { get; set; }
    
    /// <summary>
    /// Background color.
    /// </summary>
    [Parameter, EditorRequired]
    public string BackgroundColor { get; set; } = default!;
    
    private RetroItemViewModel _value = default!;
    private ElementReference _item;
    private System.Timers.Timer? _timer;

    protected override void OnInitialized()
    {
        if (!RenderContext.IsBrowser)
            return;
        
        _timer = new System.Timers.Timer(3_000);
        _timer.Elapsed += async (_, _) =>
        {
            _timer.Stop();
            await InvokeAsync(ChangeValue);
        };
        _timer.AutoReset = false;
        _timer.Start();
    }

    protected override void OnParametersSet()
    {
        _value = Value;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && RenderContext.IsBrowser)
            await JsRuntime.InvokeVoidAsync("window.browserJsFunctions.editableText.set", _item, Value.Text);
    }

    private async Task ChangeValue()
    {
        var value = await JsRuntime.InvokeAsync<string>("window.browserJsFunctions.editableText.get", _item);

        if (_value.Text != value)
        {
            _value.Text = value;
            await ValueChanged.InvokeAsync(_value);
        }
    }
    
    private void HandleInput()
    {
        _timer?.Stop();
        _timer?.Start();
    }
}