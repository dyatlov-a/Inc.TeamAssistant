@page "/backlog/{RoomId:guid}"
@page "/ru/backlog/{RoomId:guid}"
@page "/en/backlog/{RoomId:guid}"

@attribute [Authorize]

@inject TenantStore TenantStore
@inject IRetroService RetroService
@inject RequestProcessor RequestProcessor
@inject NavRouter NavRouter

<MetaDataModule />

<AuthorizeView>
    <Authorized>
        <Backlog
            RoomId="RoomId"
            PageSize="PageSize"
            State="_state"
            Loaders="_loaders"
            ActionItems="_actionItems"
            CurrentPersonId="context.User.ToPerson().Id"
            FacilitatorId="_facilitatorId"
            Retry="Load"
            LinkFactory="@(v => NavRouter.CreateRoute(v))"
            ActionItemChanged="OnActionItemChanged"
            LoadHistory="OnLoadHistory" />
    </Authorized>
</AuthorizeView>

@code {
    [Parameter, EditorRequired]
    public Guid RoomId { get; set; }
    
    private readonly LoadingState _state = LoadingState.Done();
    private readonly List<ActionItemViewModel> _actionItems = new();
    private const int PageSize = 10;
    private long? _facilitatorId;
    private readonly Dictionary<string, LoadingState> _loaders = new(StringComparer.InvariantCultureIgnoreCase);
    
    protected override async Task OnParametersSetAsync() => await Load();
    
    private async Task Load()
    {
        await TenantStore.Initialize(RoomId, _state);
        
        var result = await RequestProcessor.Process(
            async () => await RetroService.GetActionItems(RoomId, PageSize),
            nameof(BacklogContainer),
            _state);

        _facilitatorId = result.FacilitatorId;
            
        _actionItems.Clear();
        foreach (var actionItem in result.Items)
            ApplyActionItemChanged(actionItem);

        foreach (var stage in ActionItemStages.All)
            if (_actionItems.Count(i => stage.Equals(i.State, StringComparison.InvariantCultureIgnoreCase)) == PageSize)
                _loaders.Add(stage, LoadingState.Done());
    }
    
    private void ApplyActionItemChanged(ActionItemDto changed)
    {
        var viewActionItem = _actionItems.SingleOrDefault(i => i.Id == changed.Id);
        if (viewActionItem is null)
            _actionItems.Add(new ActionItemViewModel(changed.Id, changed.RetroItemId, changed.Created).Apply(changed));
        else
            viewActionItem.Apply(changed);
    }
    
    private async Task OnActionItemChanged(ActionItemViewModel item)
    {
        await RequestProcessor.Process(
            async () => await RetroService.ChangeActionItem(item.ToCommand(RoomId)),
            _state,
            showLoading: false);
    }

    private async Task OnLoadHistory(string stage)
    {
        if (_loaders.TryGetValue(stage, out var loader))
        {
            var offset = _actionItems.Count(i => stage.Equals(i.State, StringComparison.InvariantCultureIgnoreCase));
            var result = await RequestProcessor.Process(
                async () => await RetroService.GetActionItemsHistory(RoomId, stage, offset, PageSize),
                loader);

            if (result.Items.Any())
                foreach (var item in result.Items)
                    ApplyActionItemChanged(item);
            
            if (result.Items.Count < PageSize)
                _loaders.Remove(stage);
        }
    }
}